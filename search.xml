<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于Harbor搭建Docker本地私服]]></title>
    <url>%2F2020%2F04%2F27%2F%E5%9F%BA%E4%BA%8EHarbor%E6%90%AD%E5%BB%BADocker%E6%9C%AC%E5%9C%B0%E7%A7%81%E6%9C%8D%2F</url>
    <content type="text"><![CDATA[安装Harbor安装Harbor的前提条件是，本地已经装好了Docker-Compose。 我们可以从https://github.com/goharbor/harbor/releases找到Harbor的离线安装包。 在我们下载好harbor-offline-installer-v1.10.2.tgz，并进行解压。 tar -zxvf harbor-offline-installer-v1.10.2.tgz 随后进入解压好的目录， # 修改 harbor.yml hostname配置，同时也可以修改默认端口及默认登陆密码信息。 vim harbor.yml # 在配置文件修改完成后，执行安装程序 sh install.sh # Configuration file of Harbor # The IP address or hostname to access admin UI and registry service. # DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients. hostname: 192.168.1.130 # http related config http: # port for http, default is 80. If https enabled, this port will redirect to https port port: 80 # https related config # https: # # https port for harbor, default is 443 # port: 443 # # The path of cert and key files for nginx # certificate: /your/certificate/path # private_key: /your/private/key/path # Uncomment external_url if you want to enable external proxy # And when it enabled the hostname will no longer used # external_url: https://reg.mydomain.com:8433 # The initial password of Harbor admin # It only works in first time to install harbor # Remember Change the admin password from UI after launching Harbor. harbor_admin_password: Harbor12345 待完全启动后，我们在浏览器打开192.168.1.130，不出意外就会出现Harbor的登陆页面，使用配置文件中的密码进行登陆即可。 常用命令 停止服务： docker-compose stop 开始服务： docker-compose start Docker配置私服 # 修改 docker 接入私服 vim /etc/docker/daemon.json &quot;insecure-registries&quot; : [&quot;192.168.1.130&quot;] # 重启docker systemctl restart docker 页面使用首先我们先看下登陆后的Harbor主页面 项目：就是我们需要使用到的私有化仓库地址。 我们可以点击项目名称，进入项目明细页面 里面有推送私有镜像的方法 制作镜像docker tag nginx:latest 192.168.1.130/library/nginx:0.0.1 上传登陆私服docker login 192.168.1.130 上传镜像到私服docker push 192.168.1.130/library/nginx:0.0.1 打开网页，我们可以看到镜像仓库已经有我们刚才上传的镜像了]]></content>
      <tags>
        <tag>Docker Harbor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[半小时Docker简单入门]]></title>
    <url>%2F2019%2F12%2F30%2F%E5%8D%8A%E5%B0%8F%E6%97%B6Docker%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[安装最新Docker这里安装主要基于Linux环境下的安装，Windows环境可以直接使用Docker Desktop。 安装 Docker 官方源 sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 如果这里提示yum-config-manager：未找到命令，我们需要先安装yum工具。 yum install -y yum-utils 更新源 yum makecache fast 安装docker-ce yum install -y docker-ce 设置开机执行 systemctl enable docker 启动docker systemctl start docker 检查docker版本 docker version 镜像操作下载镜像docker pull name:tag 默认镜像的下载地址为https://hub.docker.com/ 由于镜像地址在国外，但是由于显而易见的网络原因，拉取镜像的过程非常耗时，严重影响使用 Docker 的体验。 因此我们需要将Docker的镜像地址执行国内的第三方仓库，这样可以极大的提高国内网络访问Docker Hub的速度。 curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io #该脚本可以将 --registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中 #同时，您也可以自己编辑vim /etc/docker/deamon.json文件，注意一定要符合json格式要求。 # { # &quot;registry-mirrors&quot;: [&quot;http://f1361db2.m.daocloud.io&quot;] # } 查看本地已下载镜像docker images REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 删除本地已下载镜像docker rmi image_id 端口操作docker run --name name -d -p 8080:80 nginx:1.17 –name：为容器指定一个名称。 -d：后台运行容器，并返回容器ID。 -p：指定端口映射，格式为：主机(宿主)端口:容器端口。同时支持多端口映射， -p 80-90:80-90。 挂载操作docker run --name name -d -p 8080:80 -v /data:/usr/share/nginx/html nginx:1.17 -v：绑定一个卷，前面是宿主机的目录，后面是容器目录。 日志操作docker logs -f 容器名称或容器ID 容器操作docker exec -it 容器名称 sh -i：标准输入。 -t：分配一个伪终端。 删除容器docker rm -f 容器名称 -f：通过 SIGKILL 信号强制删除一个运行中的容器。 如果不加 -f 则无法删除一个正在运行的容器，需要首先docker stop 容器名称。 网络操作docker inspect 容器名称 通过Dockerfile文件构建镜像docker built . -t name:tag 使用当前目录的Dockerfile创建镜像。 -t：指定构建镜像的名字和标签。 -f：指定要使用的Dockerfile的完整路径。 -m：设置内存最大值。 Dockerfile示例FROM centos #制作base image 基础镜像，尽量使用官方的image作为base image LABEL version=&quot;1.0&quot; #容器元信息，帮助信息，Metadata，类似于代码注释 LABEL maintainer=&quot;author&quot; #容器作者信息 #对于复杂的RUN命令，避免无用的分层，多条命令用反斜线换行，合成一条命令！ RUN yum update &amp;&amp; yum install -y vim \ Python-dev #反斜线换行 WORKDIR /root #相当于linux的cd命令，改变目录，尽量使用绝对路径！！！不要用RUN cd WORKDIR /test # 如果没有就自动创建 ADD test.tar.gz / # 添加到根目录并解压 COPY hello test/ # 等同于上述ADD效果 ADD与COPY - 优先使用COPY命令 -ADD除了COPY功能还有解压功能 ENV # 环境变量，尽可能使用ENV增加可维护性 ENV MYSQL_VERSION 5.6 # 设置一个mysql常量 安装Docker-Composesudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose docker-compose --version #这里使用的是1.25.4版本，如果需要其他的版本，打开`https://github.com/docker/compose/releases`找到需要的版本号进行替换即可]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot格式化JSON日期]]></title>
    <url>%2F2019%2F11%2F16%2FBoot%E6%A0%BC%E5%BC%8F%E5%8C%96JSON%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1.概述本文基于Jackson而来，Jackson被Spring Boot 用作其默认JSON处理器，下面将展示如何在Spring Boot应用程序中格式化JSON日期字段。 2.在日期字段上使用@JsonFormat2.1 设定格式我们可以使用 @JsonFormat注释来格式化特定字段： public class Contact { // other fields @JsonFormat(pattern=&quot;yyyy-MM-dd&quot;) private LocalDate birthday; @JsonFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;) private LocalDateTime updateTime; // standard getters and setters } 在birthday字段中，我们使用仅显示日期的模式，而在updateTime字段中还包含时间。 这里使用了Java8的日期类型，如果我们需要使用java.util.Date之类的遗留类型 ，则可以通过相同的方式使用注释。 最后，让我们看一下使用具有给定日期格式的@JsonFormat 呈现的输出： { &quot;birthday&quot;: &quot;2019-08-29&quot;, &quot;updateTime&quot;: &quot;2019-08-29 16:58:12&quot; } 如我们所见，使用@JsonFormat 批注是格式化特定日期字段的绝佳方法。 但是，仅在需要字段的特定格式时才应使用它。如果我们希望对应用程序中的所有日期都采用通用格式，那么有更好的方法来实现这一点，我们将在后面介绍。 2.2 设定时区另外，如果需要使用特定的时区，则可以设置@JsonFormat的timezone属性： @JsonFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;, timezone=&quot;Asia/Shanghai&quot;) private LocalDateTime updateTime; 如果类型已经包含时区，例如在java.time.ZonedDatetime中，则我们不需要使用它 。 3.配置默认格式如果我们不想在每个字段上都添加上注解的话，我们也可以使用配置文件来为应用程序中的日期配置默认格式，并且这种方式更灵活，我们只需要在applicaiton.yml加入如下配置： spring: jackson: date-format: yyyy-MM-dd HH:mm:ss 而且，如果我们想在JSON日期中使用特定的时区，则还有一个属性： spring: jackson: time-zone: Asia/Shanghai 尽管像这样设置默认格式非常方便和直接，但是这种方法还是有一个缺点。它不支持Java8的日期类型，例如LocalDate和LocalDateTime，它只能用来格式化Date或Calendar类型的字段。 4.自定义Jackson的ObjectMapper因此，如果我们想使用Java 8日期类型，并设置默认的日期格式，那么我们需要研究创建Jackson2ObjectMapperBuilderCustomizer： @Configuration @ConditionalOnClass(ObjectMapper.class) @AutoConfigureBefore(JacksonAutoConfiguration.class) public class JacksonConfig { private static final String NORM_DATE_PATTERN = &quot;yyyy-MM-dd&quot;; private static final String NORM_TIME_PATTERN = &quot;HH:mm:ss&quot;; private static final String NORM_DATETIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;; @Bean public Jackson2ObjectMapperBuilderCustomizer customizer() { return builder -&gt; { builder.simpleDateFormat(NORM_DATETIME_FORMAT); //属性值为null的不参与序列化 builder.serializationInclusion(JsonInclude.Include.NON_NULL); builder.serializers(new LocalTimeSerializer(DateTimeFormatter.ofPattern(NORM_TIME_PATTERN))); builder.serializers(new LocalDateSerializer(DateTimeFormatter.ofPattern(NORM_DATE_PATTERN))); builder.serializers(new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(NORM_DATETIME_FORMAT))); }; } } 上面的示例显示了如何在我们的应用程序中配置默认格式。我们必须定义一个bean并覆盖它的customize方法来设置所需的格式，重要的是它可以同时支持Java8和旧式日期类型。 5.其他注意事项5.1 无法找到com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer需要我们在Pom添加额外的依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/dependency&gt;]]></content>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringCloud微服务整合SpringSecurity完成Oauth认证]]></title>
    <url>%2F2019%2F08%2F30%2FSpring-Clouod-Security%2F</url>
    <content type="text"><![CDATA[最近在看微服务的相关知识，也自己尝试着搭建一个微服务框架，目前服务注册中心选择的是阿里巴巴的Nacos，网关模块使用的是Spring Cloud Gateway，然后认证服务器这块摒弃了之前项目一直使用的Shiro，开始学习使用Spring Security，这篇文章就记录一下Spring Cloud整合Spring Security的过程。 目前的项目使用的Spring Cloud版为Greenwich.SR2，Spring Boot版本为2.1.6.RELEASE。 首先需要在项目Maven中引入相关的组件。 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; Spring Security Oauth2框架在使用Spring Security搭建认证服务器的时候绕不开两个适配器类，分别是WebSecurityConfigurerAdapter和AuthorizationServerConfigurerAdapter。 我们首先来看下WebSecurityConfigurerAdapter。 WebSecurityConfigurerAdapterWebSecurityConfigurerAdapter里有三个configure方法。 1public void configure(WebSecurity web) throws Exception &#123;&#125; 1protected void configure(HttpSecurity http) throws Exception &#123;&#125; 1protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;&#125; 我们主要覆盖的是configure(HttpSecurity http)这个方法。 123456789101112131415@Overrideprotected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() //对请求的授权配置 .antMatchers("/actuator/**").permitAll() //访问/actuator/**请求不需要授权 .anyRequest().authenticated() //只要不是/actuator/**的请求都需要授权才能访问 .and().csrf().disable(); //禁用csrf&#125;@Bean@Overridepublic AuthenticationManager authenticationManagerBean() throws Exception &#123; //必须注入 AuthenticationManager，不然oauth 无法处理四种授权方式 return super.authenticationManagerBean();&#125; AuthorizationServerConfigurerAdapter我们通过继承AuthorizationServerConfigurerAdapter来配置OAuth2认证服务器，它里面也有三个configure方法。 1public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;&#125; 1public void configure(AuthorizationServerSecurityConfigurer security) throws Exception &#123;&#125; 1public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123;&#125; ClientDetailsServiceConfigurer：这个configurer定义了客户端的细节服务，我们可以通过重写这个方法来定义一个基于内存的或者JDBC的客户端信息服务。如果是通过JDBC模式的话，我们本地需要建立一张表，该表的建表语句可以参考：https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql。 AuthorizationServerSecurityConfigurer：配置令牌端点(Token Endpoint)的安全约束。 AuthorizationServerEndpointsConfigurer：用来配置授权（authorization）以及令牌（token）的访问端点和令牌服务(token services)。在这个方法里，我们可以配置我们的Token存储方式、个性化token设置、自定义userDetailsService的实现及Endpoints的请求方式。 123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration@AllArgsConstructor@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter &#123;​ private final DataSource dataSource;​ private final UserDetailsService userDetailsService;​ private final RedisConnectionFactory redisConnectionFactory;​ private final AuthenticationManager authenticationManager;​ private final String REDIS_TOKEN_PREFIX = "YEE:OAUTH:CODE:";​ @Override​ public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;​ JdbcClientDetailsService jdbcClientDetailsService = new JdbcClientDetailsService(dataSource);​ jdbcClientDetailsService.setSelectClientDetailsSql("select client_id, CONCAT('&#123;noop&#125;',client_secret) as client_secret, resource_ids, scope, authorized_grant_types, web_server_redirect_uri, authorities, access_token_validity, refresh_token_validity, additional_information, autoapprove from oauth_client_details where client_id = ?");​ clients.withClientDetails(jdbcClientDetailsService);​ &#125;​ @Override​ public void configure(AuthorizationServerSecurityConfigurer security) &#123;​ // 允许表单认证​ security.allowFormAuthenticationForClients();​ &#125;​ @Override​ public void configure(AuthorizationServerEndpointsConfigurer endpoints) &#123;​ endpoints​ .allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST)​ .tokenStore(tokenStore())​ .userDetailsService(userDetailsService)​ .authenticationManager(authenticationManager);​ &#125;​ @Bean​ public TokenStore tokenStore() &#123;​ RedisTokenStore redisTokenStore = new RedisTokenStore(redisConnectionFactory);​ redisTokenStore.setPrefix(REDIS_TOKEN_PREFIX);​ return redisTokenStore;​ &#125;&#125; 一个标准的密码模式获取token的url应该是：http://localhost:8080/oauth/token?client_id=demo&amp;client_secret=demo&amp;grant_type=password&amp;username=admin&amp;password=admin。 其中client_id和client_secret也可以放到请求头中，使用Base64加密client_id:client_secret，然后在请求头中添加：”Authorization” : “Basic 加密后的字符串”]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExcutor概述]]></title>
    <url>%2F2019%2F08%2F15%2FThreadPoolExcutor%2F</url>
    <content type="text"><![CDATA[之前在代码中使用Timer类时，阿里巴巴代码规范提示要使用ScheduledExecutorService代替Timer吧，理由是Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。于是又去查阅了ScheduledExecutorService及ThreadPoolExecutor 翻看了ThreadPoolExecutor的代码发现ThreadPoolExecutor有四个构造方法。 12345public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 123456public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) 123456public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 我们取参数最多的构造方法来看 corePoolSize：核心线程池大小。 maximumPoolSize：线程池内最大线程数。 keepAliveTime：线程池空闲时，线程存活的时间 unit：时间单位。 workQueue：线程等待队列 threadFactory：线程创建工厂，可以重写，之定义线程名称、优先级等。 handler：拒绝策略 一、Core and maximum pool sizes 核心和最大线程池数量 线程池执行器将会根据corePoolSize和maximumPoolSize自动地调整线程池大小。 当有任务提交时，如果当前线程池中的线程数小于核心线程数，那么就会创建一个新的线程来处理该任务，如果当前线程池中的线程数大于等于核心线程数但是小于最大线程数，那么则将任务放到workQueue中进行等待。如果线程池中的线程数大于等于最大线程数，那么就执行拒绝策略。通过设置corePoolSize和maximumPoolSize相同，您可以创建一个固定大小的线程池。 二、keepAliveTime 线程存活时间 如果线程池当前拥有超过corePoolSize的线程，那么多余的线程在空闲时间超过keepAliveTime时会被销毁。 三、workQueue 等待队列 BlockingQueu用于存放提交的任务，队列的实际容量与线程池大小相关联。 如果当前线程池任务线程数量小于核心线程池数量，执行器总是优先创建一个任务线程，而不是从线程队列中取一个空闲线程。 如果当前线程池任务线程数量大于核心线程池数量，执行器总是优先从线程队列中取一个空闲线程，而不是创建一个任务线程。 如果当前线程池任务线程数量大于核心线程池数量，且队列中无空闲任务线程，将会创建一个任务线程，直到超出maximumPoolSize，如果超时maximumPoolSize，则任务将会被拒绝。 主要有三种队列策略： Direct handoffs 直接握手队列 Direct handoffs 的一个很好的默认选择是 SynchronousQueue，它将任务交给线程而不需要保留。这里，如果没有线程立即可用来运行它，那么排队任务的尝试将失败，因此将构建新的线程。 此策略在处理可能具有内部依赖关系的请求集时避免锁定。Direct handoffs 通常需要无限制的maximumPoolSizes来避免拒绝新提交的任务。 但得注意，当任务持续以平均提交速度大余平均处理速度时，会导致线程数量会无限增长问题。 Unbounded queues 无界队列 当所有corePoolSize线程繁忙时，使用无界队列（例如，没有预定义容量的LinkedBlockingQueue）将导致新任务在队列中等待，从而导致maximumPoolSize的值没有任何作用。当每个任务互不影响，完全独立于其他任务时，这可能是合适的; 例如，在网页服务器中， 这种队列方式可以用于平滑瞬时大量请求。但得注意，当任务持续以平均提交速度大余平均处理速度时，会导致队列无限增长问题。 Bounded queues 有界队列 一个有界的队列（例如，一个ArrayBlockingQueue）和有限的maximumPoolSizes配置有助于防止资源耗尽，但是难以控制。队列大小和maximumPoolSizes需要 相互权衡： 使用大队列和较小的maximumPoolSizes可以最大限度地减少CPU使用率，操作系统资源和上下文切换开销，但会导致人为的低吞吐量。如果任务经常被阻塞（比如I/O限制），那么系统可以调度比我们允许的更多的线程。 使用小队列通常需要较大的maximumPoolSizes，这会使CPU更繁忙，但可能会遇到不可接受的调度开销，这也会降低吞吐量。 四、ThreadFactory 线程工厂 新线程使用ThreadFactory创建。 如果未另行指定，则使用Executors.defaultThreadFactory默认工厂，使其全部位于同一个ThreadGroup中，并且具有相同的NORM_PRIORITY优先级和非守护进程状态。 五、RejectedExecutionHandler拒绝任务 拒绝任务有两种情况：1. 线程池已经被关闭；2. 任务队列已满且maximumPoolSizes已满；无论哪种情况，都会调用RejectedExecutionHandler的rejectedExecution方法。预定义了四种处理策略： AbortPolicy：默认策略，当任务被拒绝将跑出运行时异常RejectedExecutionException CallerRunsPolicy：线程调用运行该任务的线程本身来执行，相当于直接在主线程中执行任务。 DiscardPolicy：直接丢弃新提交的任务。 DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）]]></content>
      <categories>
        <category>ThreadPoolExcutor</category>
      </categories>
      <tags>
        <tag>ThreadPoolExcutor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security OAuth核心类解析]]></title>
    <url>%2F2019%2F07%2F11%2FSpring-Security-OAuth%2F</url>
    <content type="text"><![CDATA[前言 从工作到现在也经历过不少的项目了，在权限管理那块使用的一直都是Shiro安全框架。直到最近一段时间学习了微服务相关知识，接触到了Spring Security，才发现Security的强大功能。相对shiro而言，Spring Security显得并不是那么好用，甚至是有些复杂，想要弄懂并不是很容易。通过查找资料，理解Spring Security Oauth2的基本原理，知道Spring Security Oauth2是如何实现的，这对使用Security是很有帮助的，特在此记录一下。 先用一张图展示一下Spring Security Oauth2的运行流程上图蓝色的方块代表执行过程中调用的具体的类，绿色的方块代表整个执行流程中调用的类，绿色的括号中代表的是该接口调用的具体的实现类。整个流程的入口点是在TokenEndpoint，由它来处理获取令牌的请求，获取令牌的请求默认是/oauth/token这个路径。 流程解析 在请求到达/oauth/token之前经过了ClientCredentialsTokenEndpointFilter这个过滤器，使用clientId和clientSecret组装成一个UsernamePasswordAuthenticationToken作为身份标识，使用容器中的顶级身份管理器AuthenticationManager去进行身份认证。 （AuthenticationManager的实现类一般是ProviderManager。而ProviderManager内部维护了一个List,真正的身份认证是由一系列AuthenticationProvider去完成。而AuthenticationProvider的常用实现类则是DaoAuthenticationProvider，DaoAuthenticationProvider内部又聚合了一个UserDetailsService接口，UserDetailsService才是获取用户详细信息的最终接口） 当TokenEndpoint收到请求时，它首先会调用ClientDetailsService,ClientDetaisService从名字上看就很可以知道是一个类似于UserDetailsService的接口，只不过UserDetailsService读取的是用户的信息，而ClientDetailsService读取的是第三方应用的信息。 当请求头中带上Client的信息，而这个类就可以做到根据ClientId读取相应的配置信息。而ClientDetailsSevice读取到的信息都会封装到ClientDetails这个对象中。 同时，TokenEndpoint还会创建一个TokenRequests的对象，这个对象中封装了除了第三方应用以外的其他信息。比如说grant_type,scope,username,password(限密码模式)等等信息，而这些信息都是封装在TokenRequests里面的。同时ClientDetails也会被放到TokenRequests中，因为第三方应用的信息也是令牌请求的一部分。 之后利用TokenRequests去调用一个叫做TokenGranter的令牌授权者的接口，这个接口其实是对四种不同的授权模式进行的一个封装。在这个接口里，它会根据请求传递过来的grant_type去挑一个具体的实现来执行令牌生成的逻辑 不论采用哪种方式进行令牌的生成，在这个生成的过程中都会产生两个对象，一个是OAuth2Request,这个对象实际上是之前的ClientDetails和TokenRequests这两个对象的一个整合。另一个Authorization封装的实际上是当前授权用户的一些信息，也就是谁在进行授权行为，Authorization里封装的就是谁的信息。这里的用户信息是通过UserDetailsService进行读取的。 OAuth2Request和Authorization这两个对象组合起来，会形成一个OAuth2Authorization对象，而这个最终产生的对象它的里面就包含了当前是哪个第三方应用在请求哪个用户以哪种授权模式（包括授权过程中的一些其他参数）进行授权，也就是这个对象会汇总之前的几个对象的信息都会封装到OAuth2Authorization这个对象中。 然后这个对象会传递到一个叫做AuthorizationServerTokenServices的接口的实现类，它拿到OAuth2Authorization中所有的信息之后最终会生成一个OAuth2的令牌OAuth2AccessToken。 AuthorizationServerTokenServices的接口的默认实现DefaultTokenServices中包含着其他两个接口的引用，TokenStore是用来定制token存储策略的，实现类有InMemoryTokenStore、JdbcTokenStore、JwkTokenStore、RedisTokenStore。TokenEnhancer是token的增强器，用于自定义令牌信息。相关链接理解OAuth 2.0OAuth官网OAuth2-spring-security-guide]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Security</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Boot格式化JSON日期]]></title>
    <url>%2F2019%2F11%2F16%2FBoot%E6%A0%BC%E5%BC%8F%E5%8C%96JSON%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1.概述本文基于Jackson而来，Jackson被Spring Boot 用作其默认JSON处理器，下面将展示如何在Spring Boot应用程序中格式化JSON日期字段。 2.在日期字段上使用@JsonFormat2.1 设定格式我们可以使用 @JsonFormat注释来格式化特定字段： 1234567891011public class Contact &#123; // other fields @JsonFormat(pattern="yyyy-MM-dd") private LocalDate birthday; @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss") private LocalDateTime updateTime; // standard getters and setters&#125; 在birthday字段中，我们使用仅显示日期的模式，而在updateTime字段中还包含时间。 这里使用了Java8的日期类型，如果我们需要使用java.util.Date之类的遗留类型 ，则可以通过相同的方式使用注释。 最后，让我们看一下使用具有给定日期格式的@JsonFormat 呈现的输出： 1234&#123; "birthday": "2019-08-29", "updateTime": "2019-08-29 16:58:12"&#125; 如我们所见，使用@JsonFormat 批注是格式化特定日期字段的绝佳方法。 但是，仅在需要字段的特定格式时才应使用它。如果我们希望对应用程序中的所有日期都采用通用格式，那么有更好的方法来实现这一点，我们将在后面介绍。 2.2 设定时区另外，如果需要使用特定的时区，则可以设置@JsonFormat的timezone属性： 12@JsonFormat(pattern="yyyy-MM-dd HH:mm:ss", timezone="Asia/Shanghai")private LocalDateTime updateTime; 如果类型已经包含时区，例如在java.time.ZonedDatetime中，则我们不需要使用它 。 3.配置默认格式如果我们不想在每个字段上都添加上注解的话，我们也可以使用配置文件来为应用程序中的日期配置默认格式，并且这种方式更灵活，我们只需要在applicaiton.yml加入如下配置： 123spring: jackson: date-format: yyyy-MM-dd HH:mm:ss 而且，如果我们想在JSON日期中使用特定的时区，则还有一个属性： 123spring: jackson: time-zone: Asia/Shanghai 尽管像这样设置默认格式非常方便和直接，但是这种方法还是有一个缺点。它不支持Java8的日期类型，例如LocalDate和LocalDateTime，它只能用来格式化Date或Calendar类型的字段。 4.自定义Jackson的ObjectMapper因此，如果我们想使用Java 8日期类型，并设置默认的日期格式，那么我们需要研究创建Jackson2ObjectMapperBuilderCustomizer： 12345678910111213141516171819@Configuration@ConditionalOnClass(ObjectMapper.class)@AutoConfigureBefore(JacksonAutoConfiguration.class)public class JacksonConfig &#123; private static final String NORM_DATE_PATTERN = "yyyy-MM-dd"; private static final String NORM_TIME_PATTERN = "HH:mm:ss"; private static final String NORM_DATETIME_FORMAT = "yyyy-MM-dd HH:mm:ss"; @Bean public Jackson2ObjectMapperBuilderCustomizer customizer() &#123; return builder -&gt; &#123; builder.simpleDateFormat(NORM_DATETIME_FORMAT); //属性值为null的不参与序列化 builder.serializationInclusion(JsonInclude.Include.NON_NULL); builder.serializers(new LocalTimeSerializer(DateTimeFormatter.ofPattern(NORM_TIME_PATTERN))); builder.serializers(new LocalDateSerializer(DateTimeFormatter.ofPattern(NORM_DATE_PATTERN))); builder.serializers(new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(NORM_DATETIME_FORMAT))); &#125;; &#125;&#125; 上面的示例显示了如何在我们的应用程序中配置默认格式。我们必须定义一个bean并覆盖它的customize方法来设置所需的格式，重要的是它可以同时支持Java8和旧式日期类型。 5.其他注意事项5.1 无法找到com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer需要我们在Pom添加额外的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Jackson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud整合nacos实现微服务注册中心]]></title>
    <url>%2F2019%2F10%2F22%2Fspringcloud%E6%95%B4%E5%90%88nacos%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Nacos简介Nacos是阿里巴巴公司开源的一个微服务注册组件， 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。 目前可以很方便的使用Nacos来替换Eureka作为Spring Cloud微服务的注册中心及配置中心。 Nacos安装你可以通过源码和发行包两种方式来获取 Nacos。 从Github上下载源码自己进行编译。 从官网下载稳定版本解压后使用。 更多安装步骤在这不做过多阐述，请浏览Nacos官网上的 快速开始 以快速上手 Nacos。 程序启动后，我们可以看到Nacos控制台的地址及端口号 用户名和密码均为nacos。 Spring Cloud整合Nacos引入依赖12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 12345678910111213141516171819202122232425&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 配置文件 spring.application.name：注册到nacos上的服务名称。 spring.cloud.nacos.discovery.server-addr：Nacos Server启动监听的ip地址和端口。 另外需要在启动类加上@EnableDiscoveryClient注解才能被Nacos发现。 在我们启动程序后，我们可以在控制台或者日志中看到如下内容，代表服务已经注册成功。 12019-10-11 11:30:56.679 INFO 11332 --- [ main] c.a.c.n.registry.NacosServiceRegistry : nacos registry, yee-gateway 192.168.202.108:8052 register finished 然后我们打开Nacos控制台来查看服务列表，可以看到我们的服务已经在列表中展示。]]></content>
      <categories>
        <category>-Spring Cloud</category>
      </categories>
      <tags>
        <tag>-Spring Cloud - Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Cloud-Oauth认证]]></title>
    <url>%2F2019%2F09%2F23%2FSpring-Cloud-Oauth%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[Oauth2是什么OAuth 2.0是用于授权的行业标准协议，它可以使第三方应用程序或客户端获得对HTTP服务上（例如 Google，GitHub ）用户帐户信息的有限访问权限。OAuth 2 通过将用户身份验证委派给托管用户帐户的服务以及授权客户端访问用户帐户进行工作。 OAuth 2.0定义了四种授权方式。 授权码模式 简化模式 密码模式 客户端模式 Oauth2使用添加依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt; 认证原理在使用Oauth之前，我们首先来学习下Spring Security OAuth的基本原理。 下面这张图涉及到了Spring OAuth的一些核心类和接口。 上图蓝色的方块代表执行过程中调用的具体的类，绿色的方块代表整个执行流程中调用的接口，绿色的括号中代表的是该接口调用的具体的实现类。 其实整个流程的入口点是在TokenEndpoint，由它来处理获取令牌的请求，获取令牌的请求是/oauth/token这个路径，但是在请求达到/oauth/token之前还会经过ClientCredentialsTokenEndpointFilter处理。 ClientCredentialsTokenEndpointFilter是Oauth2 TokenEndpoint的认证端口，它用来解析请求中的client_id和client_secret，然后构造成UsernamePasswordAuthenticationToken，然后交给ProviderManager进行认证。由DaoAuthenticationProvider执行认证发放，通过ClientDetailsService.loadClientByClientId方法向表oauth_client_details查询ClientDetails信息。 在clientDetails信息校验通过后，请求来到TokenEndpoint，从UsernamePasswordAuthenticationToken解析出client_id信息，然后再通过ClientDetailsService.loadClientByClientId查询ClientDetails信息，将从表oauth_client_details查询到的数据封装到ClientDetails这个对象中。 同时，TokenEndpoint还会创建一个TokenRequest对象，这个对象封装了除了第三方应用以外的其他信息，比如说grant_type、scope、username、password（限密码模式）等等信息，而这些信息都是封装在TokenRequests里面的。同时，ClientDetails也会被放到TokenRequests中，因为第三方应用的信息也是令牌请求的一部分。 之后利用TokenRequests去调用令牌授权者（TokenGranter）的接口。这个接口其实是对四种不同的授权模式进行的一个封装。在这个接口里，它会根据请求传递过来的grant_type去挑一个具体的实现来执行令牌生成的逻辑。 不论采用哪种方式进行令牌的生成，在这个的过程中都会产生Oauth2Request和Authentication对象。OAuth2Request是之前ClientDetails和TokenRequests这两个对象的一个整合，Authorization则是封装当前用户的一些授权信息。也就是谁在进行授权行为，Authorization里封装的就是谁的信息。这里的用户信息是通过UserDetailsService进行读取的。 OAuth2Request和Authorization这两个对象结合起来，会形成一个OAuth2Authorization对象。里面封装了请求用户信息、请求对象信息、授权模式等。也就是之前的几个对象的信息都会封装到OAuth2Authorization这个对象中。 然后这个对象会传递到AuthorizationServerTokenServices的接口实现类中，取到OAuth2Authentication中所有的信息之后最终会生成一个OAuth2的令牌OAuth2AccessToken。 AuthorizationServerTokenServices的接口的默认实现DefaultTokenServices中包含着其他两个接口的引用。TokenStore是用来定制token存储策略的，常见的有 InMemoryTokenStore：将OAuth2AccessToken保存在服务器内存中。 JdbcTokenStore：将OAuth2AccessToken保存在数据库中，构造方法需要指定DataSource。 RedisTokenStore：将OAuth2AccessToken保存在Redis中，构造方法需要指定RedisConnectionFactory TokenEnhancer是token增强器，可以重写他的enhance方法来修改授权服务器返回token的内容，也可以添加自定义信息。 主要源码ClientCredentialsTokenEndpointFilter： 1234567891011121314151617181920212223242526public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException &#123; if (this.allowOnlyPost &amp;&amp; !"POST".equalsIgnoreCase(request.getMethod())) &#123; throw new HttpRequestMethodNotSupportedException(request.getMethod(), new String[]&#123;"POST"&#125;); &#125; else &#123; String clientId = request.getParameter("client_id"); String clientSecret = request.getParameter("client_secret"); Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authentication != null &amp;&amp; authentication.isAuthenticated()) &#123; return authentication; &#125; else if (clientId == null) &#123; throw new BadCredentialsException("No client credentials presented"); &#125; else &#123; if (clientSecret == null) &#123; clientSecret = ""; &#125; clientId = clientId.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(clientId, clientSecret); return this.getAuthenticationManager().authenticate(authRequest); &#125; &#125; &#125; TokenEndpoint： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@RequestMapping( value = &#123;"/oauth/token"&#125;, method = &#123;RequestMethod.POST&#125;)public ResponseEntity&lt;OAuth2AccessToken&gt; postAccessToken(Principal principal, @RequestParam Map&lt;String, String&gt; parameters) throws HttpRequestMethodNotSupportedException &#123; if (!(principal instanceof Authentication)) &#123; throw new InsufficientAuthenticationException("There is no client authentication. Try adding an appropriate authentication filter."); &#125; else &#123; String clientId = this.getClientId(principal); ClientDetails authenticatedClient = this.getClientDetailsService().loadClientByClientId(clientId); TokenRequest tokenRequest = this.getOAuth2RequestFactory().createTokenRequest(parameters, authenticatedClient); if (clientId != null &amp;&amp; !clientId.equals("") &amp;&amp; !clientId.equals(tokenRequest.getClientId())) &#123; throw new InvalidClientException("Given client ID does not match authenticated client"); &#125; else &#123; if (authenticatedClient != null) &#123; this.oAuth2RequestValidator.validateScope(tokenRequest,authenticatedClient); &#125; if (!StringUtils.hasText(tokenRequest.getGrantType())) &#123; throw new InvalidRequestException("Missing grant type"); &#125; else if (tokenRequest.getGrantType().equals("implicit")) &#123; throw new InvalidGrantException("Implicit grant type not supported from token endpoint"); &#125; else &#123; if (this.isAuthCodeRequest(parameters) &amp;&amp; !tokenRequest.getScope().isEmpty()) &#123; this.logger.debug("Clearing scope of incoming token request"); tokenRequest.setScope(Collections.emptySet()); &#125; if (this.isRefreshTokenRequest(parameters)) &#123; tokenRequest.setScope(OAuth2Utils.parseParameterList((String)parameters.get("scope"))); &#125; OAuth2AccessToken token = this.getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest); if (token == null) &#123; throw new UnsupportedGrantTypeException("Unsupported grant type: " + tokenRequest.getGrantType()); &#125; else &#123; return this.getResponse(token); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Oauth2</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java线程池]]></title>
    <url>%2F2019%2F12%2F25%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[当我们在程序中使用Java的Timer类时，阿里巴巴Java开发手册会建议我们使用ScheduledExecutorService代替Timer，具体原因也在手册中进行了说明，多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。 ScheduledExecutorService将定时任务和线程池功能结合起来，属于JDK中线程池Executor框架下的一部分。下面我们就来学习一下Java中的线程池技术，首先看下Executor框架的核心成员。 以上成员均在java.util.concurrent包中，是JDK并发包的核心类。其中，ThreadPoolExecutor表示一个线程池，Executors则扮演着线程池工厂的角色。通过Executors可以获取一个拥有特定功能的线程池。从UML图中亦可知，ThreadPoolExecutor类实现了Executor接口，因此通过这个接口，任何Runnable的对象都可以被ThreadPoolExecutor线程池调度。 创建线程池Executors类提供了一系列工厂方法用于创先线程池： public static ExecutorService newFixedThreadPool(int nThreads) public static ExecutorService newCachedThreadPool() public static ExecutorService newSingleThreadExecutor() public static ScheduledExecutorService newSingleThreadScheduledExecutor() public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) 以上工厂方法分别返回具有不同工作特性的线程池，这些线程池工厂方法的具体说明如下： newFixedThreadPool(int nThreads)方法：该方法返回一个固定线程数量的线程池，如果传入的任务数大于nThreads时不会创建新的线程，而是阻塞等待有空闲线程执行。 newCachedThreadPool()方法：该方法返回一个而根据实际情况调整线程数量的线程池，线程池的线程数量不确定，但如有空闲线程可以复用，则会优先使用可复用的线程。如果现有线程没有可用的，则创建一个新线程并添加到线程池中。终止并从缓存中移除那些已有 60秒钟未被使用的线程 newSingleThreadExecutor()方法：该方法回一个只有一个线程的线程池，串行执行所有提交的任务。 newSingleThreadScheduledExecutor()方法：该方法返回一个ScheduledExecutorService对象，线程池大小为1，ScheduledExecutorService接口在ExecutorService接口之上扩展了在给定时间执行某任务的功能，如在某个固定的延时之后执行，或者周期性的执行某个任务，多数情况下可以用来替代Timer类。 newScheduledThreadPool(int corePoolSize)方法：该方法也返回一个ScheduledExecutorService对象，但该线程池可以指定现场数量。 计划任务不同于ExecutorService，ScheduledExecutorService可以根据时间需要对线程进行调度。他的一些主要方法如下： public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) 与其他几个线程池不同，ScheduledExecutorService并不一定会立即安排执行任务，它其实是起到了计划任务的作用，方法schedule()会在给定时间，对任务进行一次调度，方法scheduleAtFixedRate()和方法scheduleWithFixedDelay()会对任务进行周期性的调度，但两者还是有一些区别的。 ScheduleAtFixedRate每次执行时间为上一次任务开始起向后推一个时间间隔，任务调度的频率是一定的。即每次执行时间为initialDelay，initialDelay+period，initialDelay+2*period ScheduleWithFixedDelay每次执行时间为上一次任务结束起向后推一个时间间隔，任务调度频率取决于任务执行时间长短每次执行时间为initialDelay，initialDelay+executeTime+delay，initialDelay+2executeTime+2delay 核心线程池对于方法newFixedThreadPool、newCachedThreadPool、newSingleThreadExecutor，虽然创建的线程池有着完全不同的功能特点，但是通过源码可以看到，其内部实现都只是ThreadPoolExecutor类的封装。下面来看一下ThreadPoolExecutor类最重要的构造方法： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize：指定了线程池中的线程数量。 maximumPoolSize：指定了线程池中的最大线程数量。 keepAliveTime：当线程池数量超过corePoolSize时，多余的空闲线程的存活时间，即超过corePoolSize的空闲线程，在多长时间内会被销毁。 unit：keepAliveTime的时间单位。 workQueue：任务队列，被提交但尚未被执行的任务。 threadFactory：线程创建工厂，可以重写，之定义线程名称、优先级等。 handler：拒绝策略，当任务太多来不及处理时，如何拒绝任务。 我们重点关注下workQueue和handler参数。 参数workQueue指被提交但未执行的任务队列，它是一个BlockingQueue接口的对象，仅用于存放Runnable对象，根据队列功能分类，在ThreadPoolExecutor类的构造函数中可以使用以下几种BlockingQueue接口。 直接提交的队列：代表类型SynchronousQueue，SynchronousQueue是一个特殊的BlockingQueue，它没有容量，每一个插入操作都要等待一个相应的删除操作。最大的特点是不保持，总是将新的任务提交给线程执行，如果没有空闲线程，则尝试创建新的线程。如果线程数量已达到最大值，则执行拒绝策略。 有界的任务队列：有界的任务队列可以使用ArrayBlockingQueue类实现。当使用有界队列时，若有新的任务需要执行，如果线程池的实际线程数小于corePoolSize，则会优先创建新的线程，若大于corePoolSize，则会将新任务加入等待队列。若等待队列已满，无法加入，则在总线程不大于maximumPoolSize的前提下，则创建新的线程执行任务。若大于maximumPoolSize，则执行拒绝策略。 无界的任务队列：无界的任务队列可以使用LinkedBlockingQueue类实现。与有界队列相比，除非系统资源耗尽，否则无界的任务队列不存在任务入队失败的情况。当有新的任务到来时，如果线程池的线程数小于corePoolSize时，则会创建新的线程执行任务，但是当线程池的线程数达到corePoolSize后，则不会继续增加了。若后续仍有新的任务加入，而又没有空闲的线程资源，则任务进入等待队列。所以线程池中执行的线程数最多只会是corePoolSize，从而导致maximumPoolSize参数也没有了意义。 优先任务队列：优先任务队列是带有执行优先级的队列。它通过PriorityBlockingQueue类实现，可以控制任务执行的先后顺序。它是一个特殊的无界队列。无论是ArrayBlockingQueue类，还是LinkedBlockingQueue类都是按照先进先出（FIFO）算法处理任务的，而PriorityBlockingQueue类则可以根据任务自身的优先级顺序先后执行。 拒绝策略拒绝任务有两种情况：1. 线程池已经被关闭；2. 任务队列已满且maximumPoolSizes已满； 无论哪种情况，都会调用RejectedExecutionHandler的rejectedExecution方法。 JDK内置的拒绝策略如下： AbortPolicy策略：该策略会直接抛出RejectedExecutionException异常，阻止系统正常工作。 CallerRunsPolicy策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务，相当于直接在主线程中执行任务。 DiscardPolicy策略：该策略直接丢弃无法处理的任务。 DiscardOldestPolicy策略：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 以上内置的策略均实现了RejectedExecutionHandler接口，若以上侧率仍无法满足实际应用的需要，完全可以自己扩展RejectedExecutionHandler接口。RejectedExecutionHandler的定义如下： 123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 其中r为请求执行的任务，executor为当前的线程池。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot格式化JSON日期]]></title>
    <url>%2F2019%2F11%2F16%2FBoot%E6%A0%BC%E5%BC%8F%E5%8C%96JSON%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1.概述本文基于Jackson而来，Jackson被Spring Boot 用作其默认JSON处理器，下面将展示如何在Spring Boot应用程序中格式化JSON日期字段。 2.在日期字段上使用@JsonFormat2.1 设定格式我们可以使用 @JsonFormat注释来格式化特定字段： 1234567891011public class Contact &#123; // other fields @JsonFormat(pattern="yyyy-MM-dd") private LocalDate birthday; @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss") private LocalDateTime updateTime; // standard getters and setters&#125; 在birthday字段中，我们使用仅显示日期的模式，而在updateTime字段中还包含时间。 这里使用了Java8的日期类型，如果我们需要使用java.util.Date之类的遗留类型 ，则可以通过相同的方式使用注释。 最后，让我们看一下使用具有给定日期格式的@JsonFormat 呈现的输出： 1234&#123; "birthday": "2019-08-29", "updateTime": "2019-08-29 16:58:12"&#125; 如我们所见，使用@JsonFormat 批注是格式化特定日期字段的绝佳方法。 但是，仅在需要字段的特定格式时才应使用它。如果我们希望对应用程序中的所有日期都采用通用格式，那么有更好的方法来实现这一点，我们将在后面介绍。 2.2 设定时区另外，如果需要使用特定的时区，则可以设置@JsonFormat的timezone属性： 12@JsonFormat(pattern="yyyy-MM-dd HH:mm:ss", timezone="Asia/Shanghai")private LocalDateTime updateTime; 如果类型已经包含时区，例如在java.time.ZonedDatetime中，则我们不需要使用它 。 3.配置默认格式如果我们不想在每个字段上都添加上注解的话，我们也可以使用配置文件来为应用程序中的日期配置默认格式，并且这种方式更灵活，我们只需要在applicaiton.yml加入如下配置： 123spring: jackson: date-format: yyyy-MM-dd HH:mm:ss 而且，如果我们想在JSON日期中使用特定的时区，则还有一个属性： 123spring: jackson: time-zone: Asia/Shanghai 尽管像这样设置默认格式非常方便和直接，但是这种方法还是有一个缺点。它不支持Java8的日期类型，例如LocalDate和LocalDateTime，它只能用来格式化Date或Calendar类型的字段。 4.自定义Jackson的ObjectMapper因此，如果我们想使用Java 8日期类型，并设置默认的日期格式，那么我们需要研究创建Jackson2ObjectMapperBuilderCustomizer： 12345678910111213141516171819@Configuration@ConditionalOnClass(ObjectMapper.class)@AutoConfigureBefore(JacksonAutoConfiguration.class)public class JacksonConfig &#123; private static final String NORM_DATE_PATTERN = "yyyy-MM-dd"; private static final String NORM_TIME_PATTERN = "HH:mm:ss"; private static final String NORM_DATETIME_FORMAT = "yyyy-MM-dd HH:mm:ss"; @Bean public Jackson2ObjectMapperBuilderCustomizer customizer() &#123; return builder -&gt; &#123; builder.simpleDateFormat(NORM_DATETIME_FORMAT); //属性值为null的不参与序列化 builder.serializationInclusion(JsonInclude.Include.NON_NULL); builder.serializers(new LocalTimeSerializer(DateTimeFormatter.ofPattern(NORM_TIME_PATTERN))); builder.serializers(new LocalDateSerializer(DateTimeFormatter.ofPattern(NORM_DATE_PATTERN))); builder.serializers(new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(NORM_DATETIME_FORMAT))); &#125;; &#125;&#125; 上面的示例显示了如何在我们的应用程序中配置默认格式。我们必须定义一个bean并覆盖它的customize方法来设置所需的格式，重要的是它可以同时支持Java8和旧式日期类型。 5.其他注意事项5.1 无法找到com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer需要我们在Pom添加额外的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Jackson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springcloud整合nacos实现微服务注册中心]]></title>
    <url>%2F2019%2F10%2F22%2Fspringcloud%E6%95%B4%E5%90%88nacos%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Nacos简介Nacos是阿里巴巴公司开源的一个微服务注册组件， 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。 目前可以很方便的使用Nacos来替换Eureka作为Spring Cloud微服务的注册中心及配置中心。 Nacos安装你可以通过源码和发行包两种方式来获取 Nacos。 从Github上下载源码自己进行编译。 从官网下载稳定版本解压后使用。 更多安装步骤在这不做过多阐述，请浏览Nacos官网上的 快速开始 以快速上手 Nacos。 程序启动后，我们可以看到Nacos控制台的地址及端口号 用户名和密码均为nacos。 Spring Cloud整合Nacos引入依赖12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 12345678910111213141516171819202122232425&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 配置文件 spring.application.name：注册到nacos上的服务名称。 spring.cloud.nacos.discovery.server-addr：Nacos Server启动监听的ip地址和端口。 另外需要在启动类加上@EnableDiscoveryClient注解才能被Nacos发现。 在我们启动程序后，我们可以在控制台或者日志中看到如下内容，代表服务已经注册成功。 12019-10-11 11:30:56.679 INFO 11332 --- [ main] c.a.c.n.registry.NacosServiceRegistry : nacos registry, yee-gateway 192.168.202.108:8052 register finished 然后我们打开Nacos控制台来查看服务列表，可以看到我们的服务已经在列表中展示。]]></content>
      <categories>
        <category>-Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-Cloud-Oauth认证]]></title>
    <url>%2F2019%2F09%2F23%2FSpring-Cloud-Oauth%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[Oauth2是什么OAuth 2.0是用于授权的行业标准协议，它可以使第三方应用程序或客户端获得对HTTP服务上（例如 Google，GitHub ）用户帐户信息的有限访问权限。OAuth 2 通过将用户身份验证委派给托管用户帐户的服务以及授权客户端访问用户帐户进行工作。 OAuth 2.0定义了四种授权方式。 授权码模式 简化模式 密码模式 客户端模式 Oauth2使用添加依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt; 认证原理在使用Oauth之前，我们首先来学习下Spring Security OAuth的基本原理。 下面这张图涉及到了Spring OAuth的一些核心类和接口。 上图蓝色的方块代表执行过程中调用的具体的类，绿色的方块代表整个执行流程中调用的接口，绿色的括号中代表的是该接口调用的具体的实现类。 其实整个流程的入口点是在TokenEndpoint，由它来处理获取令牌的请求，获取令牌的请求是/oauth/token这个路径，但是在请求达到/oauth/token之前还会经过ClientCredentialsTokenEndpointFilter处理。 ClientCredentialsTokenEndpointFilter是Oauth2 TokenEndpoint的认证端口，它用来解析请求中的client_id和client_secret，然后构造成UsernamePasswordAuthenticationToken，然后交给ProviderManager进行认证。由DaoAuthenticationProvider执行认证发放，通过ClientDetailsService.loadClientByClientId方法向表oauth_client_details查询ClientDetails信息。 在clientDetails信息校验通过后，请求来到TokenEndpoint，从UsernamePasswordAuthenticationToken解析出client_id信息，然后再通过ClientDetailsService.loadClientByClientId查询ClientDetails信息，将从表oauth_client_details查询到的数据封装到ClientDetails这个对象中。 同时，TokenEndpoint还会创建一个TokenRequest对象，这个对象封装了除了第三方应用以外的其他信息，比如说grant_type、scope、username、password（限密码模式）等等信息，而这些信息都是封装在TokenRequests里面的。同时，ClientDetails也会被放到TokenRequests中，因为第三方应用的信息也是令牌请求的一部分。 之后利用TokenRequests去调用令牌授权者（TokenGranter）的接口。这个接口其实是对四种不同的授权模式进行的一个封装。在这个接口里，它会根据请求传递过来的grant_type去挑一个具体的实现来执行令牌生成的逻辑。 不论采用哪种方式进行令牌的生成，在这个的过程中都会产生Oauth2Request和Authentication对象。OAuth2Request是之前ClientDetails和TokenRequests这两个对象的一个整合，Authorization则是封装当前用户的一些授权信息。也就是谁在进行授权行为，Authorization里封装的就是谁的信息。这里的用户信息是通过UserDetailsService进行读取的。 OAuth2Request和Authorization这两个对象结合起来，会形成一个OAuth2Authorization对象。里面封装了请求用户信息、请求对象信息、授权模式等。也就是之前的几个对象的信息都会封装到OAuth2Authorization这个对象中。 然后这个对象会传递到AuthorizationServerTokenServices的接口实现类中，取到OAuth2Authentication中所有的信息之后最终会生成一个OAuth2的令牌OAuth2AccessToken。 AuthorizationServerTokenServices的接口的默认实现DefaultTokenServices中包含着其他两个接口的引用。TokenStore是用来定制token存储策略的，常见的有 InMemoryTokenStore：将OAuth2AccessToken保存在服务器内存中。 JdbcTokenStore：将OAuth2AccessToken保存在数据库中，构造方法需要指定DataSource。 RedisTokenStore：将OAuth2AccessToken保存在Redis中，构造方法需要指定RedisConnectionFactory TokenEnhancer是token增强器，可以重写他的enhance方法来修改授权服务器返回token的内容，也可以添加自定义信息。 主要源码ClientCredentialsTokenEndpointFilter： 1234567891011121314151617181920212223242526public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException &#123; if (this.allowOnlyPost &amp;&amp; !"POST".equalsIgnoreCase(request.getMethod())) &#123; throw new HttpRequestMethodNotSupportedException(request.getMethod(), new String[]&#123;"POST"&#125;); &#125; else &#123; String clientId = request.getParameter("client_id"); String clientSecret = request.getParameter("client_secret"); Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); if (authentication != null &amp;&amp; authentication.isAuthenticated()) &#123; return authentication; &#125; else if (clientId == null) &#123; throw new BadCredentialsException("No client credentials presented"); &#125; else &#123; if (clientSecret == null) &#123; clientSecret = ""; &#125; clientId = clientId.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(clientId, clientSecret); return this.getAuthenticationManager().authenticate(authRequest); &#125; &#125; &#125; TokenEndpoint： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@RequestMapping( value = &#123;"/oauth/token"&#125;, method = &#123;RequestMethod.POST&#125;)public ResponseEntity&lt;OAuth2AccessToken&gt; postAccessToken(Principal principal, @RequestParam Map&lt;String, String&gt; parameters) throws HttpRequestMethodNotSupportedException &#123; if (!(principal instanceof Authentication)) &#123; throw new InsufficientAuthenticationException("There is no client authentication. Try adding an appropriate authentication filter."); &#125; else &#123; String clientId = this.getClientId(principal); ClientDetails authenticatedClient = this.getClientDetailsService().loadClientByClientId(clientId); TokenRequest tokenRequest = this.getOAuth2RequestFactory().createTokenRequest(parameters, authenticatedClient); if (clientId != null &amp;&amp; !clientId.equals("") &amp;&amp; !clientId.equals(tokenRequest.getClientId())) &#123; throw new InvalidClientException("Given client ID does not match authenticated client"); &#125; else &#123; if (authenticatedClient != null) &#123; this.oAuth2RequestValidator.validateScope(tokenRequest,authenticatedClient); &#125; if (!StringUtils.hasText(tokenRequest.getGrantType())) &#123; throw new InvalidRequestException("Missing grant type"); &#125; else if (tokenRequest.getGrantType().equals("implicit")) &#123; throw new InvalidGrantException("Implicit grant type not supported from token endpoint"); &#125; else &#123; if (this.isAuthCodeRequest(parameters) &amp;&amp; !tokenRequest.getScope().isEmpty()) &#123; this.logger.debug("Clearing scope of incoming token request"); tokenRequest.setScope(Collections.emptySet()); &#125; if (this.isRefreshTokenRequest(parameters)) &#123; tokenRequest.setScope(OAuth2Utils.parseParameterList((String)parameters.get("scope"))); &#125; OAuth2AccessToken token = this.getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest); if (token == null) &#123; throw new UnsupportedGrantTypeException("Unsupported grant type: " + tokenRequest.getGrantType()); &#125; else &#123; return this.getResponse(token); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Oauth2</tag>
      </tags>
  </entry>
</search>

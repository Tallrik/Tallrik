<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于Harbor搭建Docker本地私服</title>
    <link href="/2020/04/27/%E5%9F%BA%E4%BA%8EHarbor%E6%90%AD%E5%BB%BADocker%E6%9C%AC%E5%9C%B0%E7%A7%81%E6%9C%8D/"/>
    <url>/2020/04/27/%E5%9F%BA%E4%BA%8EHarbor%E6%90%AD%E5%BB%BADocker%E6%9C%AC%E5%9C%B0%E7%A7%81%E6%9C%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="安装Harbor"><a href="#安装Harbor" class="headerlink" title="安装Harbor"></a>安装Harbor</h1><p>安装Harbor的前提条件是，本地已经装好了Docker-Compose。</p><p>我们可以从<a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener">https://github.com/goharbor/harbor/releases</a>找到Harbor的离线安装包。</p><p><img src="https://imgkr.cn-bj.ufileos.com/4e2075f3-5b83-491d-a585-2cf7f75e5b1c.png" srcset="/img/loading.gif" alt></p><p>在我们下载好<strong>harbor-offline-installer-v1.10.2.tgz</strong>，并进行解压。</p><pre><code class="shell">tar -zxvf harbor-offline-installer-v1.10.2.tgz</code></pre><p>随后进入解压好的目录，</p><p><img src="https://imgkr.cn-bj.ufileos.com/50f8c0a5-fde1-40a7-a4eb-4e0ba313d86c.png" srcset="/img/loading.gif" alt></p><pre><code class="shell"># 修改 harbor.yml hostname配置，同时也可以修改默认端口及默认登陆密码信息。vim harbor.yml# 在配置文件修改完成后，执行安装程序sh install.sh</code></pre><pre><code class="shell"># Configuration file of Harbor# The IP address or hostname to access admin UI and registry service.# DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.hostname: 192.168.1.130# http related confighttp:  # port for http, default is 80. If https enabled, this port will redirect to https port  port: 80# https related config# https:#   # https port for harbor, default is 443#   port: 443#   # The path of cert and key files for nginx#   certificate: /your/certificate/path#   private_key: /your/private/key/path# Uncomment external_url if you want to enable external proxy# And when it enabled the hostname will no longer used# external_url: https://reg.mydomain.com:8433# The initial password of Harbor admin# It only works in first time to install harbor# Remember Change the admin password from UI after launching Harbor.harbor_admin_password: Harbor12345</code></pre><p>待完全启动后，我们在浏览器打开192.168.1.130，不出意外就会出现Harbor的登陆页面，使用配置文件中的密码进行登陆即可。</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>停止服务： <code>docker-compose stop</code></li><li>开始服务： <code>docker-compose start</code></li></ul><h1 id="Docker配置私服"><a href="#Docker配置私服" class="headerlink" title="Docker配置私服"></a>Docker配置私服</h1><pre><code class="shell"># 修改 docker 接入私服vim /etc/docker/daemon.json&quot;insecure-registries&quot; : [&quot;192.168.1.130&quot;]# 重启docker systemctl restart docker</code></pre><h1 id="页面使用"><a href="#页面使用" class="headerlink" title="页面使用"></a>页面使用</h1><p>首先我们先看下登陆后的Harbor主页面</p><p><img src="https://imgkr.cn-bj.ufileos.com/a1bb0fd7-b165-4097-86f0-9b903e0d39dc.png" srcset="/img/loading.gif" alt></p><p>项目：就是我们需要使用到的私有化仓库地址。</p><p>我们可以点击项目名称，进入项目明细页面</p><p><img src="https://imgkr.cn-bj.ufileos.com/1b8fde60-79e3-42bf-bd66-3cb976b67f6e.png" srcset="/img/loading.gif" alt></p><p>里面有推送私有镜像的方法</p><p><img src="https://imgkr.cn-bj.ufileos.com/c6a068a8-146a-4c31-8c19-0622a5b8eb75.png" srcset="/img/loading.gif" alt></p><h1 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h1><pre><code class="shell">docker tag nginx:latest 192.168.1.130/library/nginx:0.0.1</code></pre><h1 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h1><h2 id="登陆私服"><a href="#登陆私服" class="headerlink" title="登陆私服"></a>登陆私服</h2><pre><code class="shell">docker login 192.168.1.130</code></pre><h2 id="上传镜像到私服"><a href="#上传镜像到私服" class="headerlink" title="上传镜像到私服"></a>上传镜像到私服</h2><pre><code class="shell">docker push 192.168.1.130/library/nginx:0.0.1</code></pre><p>打开网页，我们可以看到镜像仓库已经有我们刚才上传的镜像了</p><p><img src="https://imgkr.cn-bj.ufileos.com/b0869cc0-7c4c-42d8-a3fc-22ca096ef976.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker Harbor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>半小时Docker简单入门</title>
    <link href="/2019/12/30/%E5%8D%8A%E5%B0%8F%E6%97%B6Docker%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <url>/2019/12/30/%E5%8D%8A%E5%B0%8F%E6%97%B6Docker%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="安装最新Docker"><a href="#安装最新Docker" class="headerlink" title="安装最新Docker"></a>安装最新Docker</h1><p>这里安装主要基于Linux环境下的安装，Windows环境可以直接使用Docker Desktop。</p><ol><li><p>安装 Docker 官方源</p><pre><code class="shell">sudo yum-config-manager \     --add-repo \     https://download.docker.com/linux/centos/docker-ce.repo</code></pre><p>如果这里提示<code>yum-config-manager：未找到命令</code>，我们需要先安装yum工具。</p><pre><code class="shell">yum install -y yum-utils</code></pre></li><li><p>更新源</p><pre><code class="shell">yum makecache fast</code></pre></li><li><p>安装docker-ce</p><pre><code class="shell">yum install -y docker-ce</code></pre></li><li><p>设置开机执行</p><pre><code class="shell">systemctl enable docker</code></pre></li><li><p>启动docker</p><pre><code class="shell">systemctl start docker</code></pre></li><li><p>检查docker版本</p><pre><code class="shell">docker version</code></pre></li></ol><h1 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h1><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><pre><code class="shell">docker pull name:tag</code></pre><p>默认镜像的下载地址为<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><p>由于镜像地址在国外，但是由于显而易见的网络原因，拉取镜像的过程非常耗时，严重影响使用 Docker 的体验。</p><p>因此我们需要将Docker的镜像地址执行国内的第三方仓库，这样可以极大的提高国内网络访问Docker Hub的速度。</p><pre><code class="shell">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io#该脚本可以将 --registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中#同时，您也可以自己编辑vim /etc/docker/deamon.json文件，注意一定要符合json格式要求。# {#    &quot;registry-mirrors&quot;: [&quot;http://f1361db2.m.daocloud.io&quot;]# }</code></pre><h2 id="查看本地已下载镜像"><a href="#查看本地已下载镜像" class="headerlink" title="查看本地已下载镜像"></a>查看本地已下载镜像</h2><pre><code class="shell">docker images</code></pre><p><img src="https://imgkr.cn-bj.ufileos.com/80d3ec81-4a7b-4ca6-99c3-aa304de58bc2.png" srcset="/img/loading.gif" alt="images"></p><ul><li><strong>REPOSITORY：</strong>表示镜像的仓库源</li><li><strong>TAG：</strong>镜像的标签</li><li><strong>IMAGE ID：</strong>镜像ID</li><li><strong>CREATED：</strong>镜像创建时间</li><li><strong>SIZE：</strong>镜像大小</li></ul><h2 id="删除本地已下载镜像"><a href="#删除本地已下载镜像" class="headerlink" title="删除本地已下载镜像"></a>删除本地已下载镜像</h2><pre><code class="shell">docker rmi image_id</code></pre><h1 id="端口操作"><a href="#端口操作" class="headerlink" title="端口操作"></a>端口操作</h1><pre><code class="shell">docker run --name name -d -p 8080:80 nginx:1.17</code></pre><ul><li>–name：为容器指定一个名称。</li><li>-d：后台运行容器，并返回容器ID。</li><li>-p：指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong>。同时支持多端口映射， <strong>-p 80-90:80-90</strong>。</li></ul><h1 id="挂载操作"><a href="#挂载操作" class="headerlink" title="挂载操作"></a>挂载操作</h1><pre><code class="shell">docker run --name name -d -p 8080:80 -v /data:/usr/share/nginx/html nginx:1.17</code></pre><ul><li>-v：绑定一个卷，前面是宿主机的目录，后面是容器目录。</li></ul><h1 id="日志操作"><a href="#日志操作" class="headerlink" title="日志操作"></a>日志操作</h1><pre><code class="shell">docker logs -f 容器名称或容器ID</code></pre><h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><pre><code class="shell">docker exec -it 容器名称 sh</code></pre><ul><li>-i：标准输入。</li><li>-t：分配一个伪终端。</li></ul><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><pre><code class="shell">docker rm -f 容器名称</code></pre><ul><li>-f：通过 SIGKILL 信号强制删除一个运行中的容器。</li><li>如果不加 <strong>-f</strong> 则无法删除一个正在运行的容器，需要首先<code>docker stop 容器名称</code>。</li></ul><h1 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h1><pre><code class="shell">docker inspect 容器名称</code></pre><h1 id="通过Dockerfile文件构建镜像"><a href="#通过Dockerfile文件构建镜像" class="headerlink" title="通过Dockerfile文件构建镜像"></a>通过Dockerfile文件构建镜像</h1><pre><code class="shell">docker built . -t name:tag</code></pre><p>使用当前目录的Dockerfile创建镜像。</p><ul><li>-t：指定构建镜像的名字和标签。</li><li>-f：指定要使用的Dockerfile的完整路径。</li><li>-m：设置内存最大值。</li></ul><h1 id="Dockerfile示例"><a href="#Dockerfile示例" class="headerlink" title="Dockerfile示例"></a>Dockerfile示例</h1><pre><code class="shell">FROM centos #制作base image 基础镜像，尽量使用官方的image作为base imageLABEL version=&quot;1.0&quot; #容器元信息，帮助信息，Metadata，类似于代码注释LABEL maintainer=&quot;author&quot; #容器作者信息#对于复杂的RUN命令，避免无用的分层，多条命令用反斜线换行，合成一条命令！RUN yum update &amp;&amp; yum install -y vim \    Python-dev #反斜线换行WORKDIR /root #相当于linux的cd命令，改变目录，尽量使用绝对路径！！！不要用RUN cdWORKDIR /test # 如果没有就自动创建ADD test.tar.gz /  # 添加到根目录并解压COPY hello test/  # 等同于上述ADD效果ADD与COPY   - 优先使用COPY命令    -ADD除了COPY功能还有解压功能ENV # 环境变量，尽可能使用ENV增加可维护性ENV MYSQL_VERSION 5.6 # 设置一个mysql常量</code></pre><h1 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker-Compose"></a>安装Docker-Compose</h1><pre><code class="shell">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composesudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-composedocker-compose --version#这里使用的是1.25.4版本，如果需要其他的版本，打开`https://github.com/docker/compose/releases`找到需要的版本号进行替换即可</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot格式化JSON日期</title>
    <link href="/2019/11/16/Boot%E6%A0%BC%E5%BC%8F%E5%8C%96JSON%E6%97%A5%E6%9C%9F/"/>
    <url>/2019/11/16/Boot%E6%A0%BC%E5%BC%8F%E5%8C%96JSON%E6%97%A5%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>本文基于Jackson而来，Jackson被Spring Boot 用作其默认JSON处理器，下面将展示如何在Spring Boot应用程序中格式化JSON日期字段。</p><a id="more"></a><h2 id="2-在日期字段上使用-JsonFormat"><a href="#2-在日期字段上使用-JsonFormat" class="headerlink" title="2.在日期字段上使用@JsonFormat"></a>2.在日期字段上使用<code>@JsonFormat</code></h2><h3 id="2-1-设定格式"><a href="#2-1-设定格式" class="headerlink" title="2.1 设定格式"></a>2.1 设定格式</h3><p><strong>我们可以使用  @JsonFormat注释来格式化特定字段：</strong></p><pre><code class="java">public class Contact {        // other fields    @JsonFormat(pattern=&quot;yyyy-MM-dd&quot;)        private LocalDate birthday;    @JsonFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;)        private LocalDateTime updateTime;    // standard getters and setters}</code></pre><p>在birthday字段中，我们使用仅显示日期的模式，而在updateTime字段中还包含时间。</p><p>这里使用了Java8的日期类型，如果我们需要使用<code>java.util.Date</code>之类的遗留类型 ，则可以通过相同的方式使用注释。</p><p>最后，让我们看一下使用具有给定日期格式的<code>@JsonFormat</code> 呈现的输出：</p><pre><code class="json">{    &quot;birthday&quot;: &quot;2019-08-29&quot;,    &quot;updateTime&quot;: &quot;2019-08-29 16:58:12&quot;}</code></pre><p><strong>如我们所见，使用@JsonFormat 批注是格式化特定日期字段的绝佳方法。</strong></p><p><strong>但是，仅在需要字段的特定格式时才应使用它。</strong>如果我们希望对应用程序中的所有日期都采用通用格式，那么有更好的方法来实现这一点，我们将在后面介绍。</p><h3 id="2-2-设定时区"><a href="#2-2-设定时区" class="headerlink" title="2.2 设定时区"></a>2.2 设定时区</h3><p>另外，如果需要使用特定的时区，则可以设置<code>@JsonFormat</code>的<code>timezone</code>属性：</p><pre><code class="java">@JsonFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;, timezone=&quot;Asia/Shanghai&quot;)private LocalDateTime updateTime;</code></pre><p>如果类型已经包含时区，例如在<code>java.time.ZonedDatetime</code>中，则我们不需要使用它 。</p><h2 id="3-配置默认格式"><a href="#3-配置默认格式" class="headerlink" title="3.配置默认格式"></a>3.配置默认格式</h2><p>如果我们不想在每个字段上都添加上注解的话，我们也可以使用配置文件来为应用程序中的日期配置默认格式，并且这种方式更灵活，我们只需要在<code>applicaiton.yml</code>加入如下配置：</p><pre><code class="yml">spring:    jackson:        date-format: yyyy-MM-dd HH:mm:ss</code></pre><p>而且，如果我们想在JSON日期中使用特定的时区，则还有一个属性：</p><pre><code class="yml">spring:    jackson:      time-zone: Asia/Shanghai</code></pre><p>尽管像这样设置默认格式非常方便和直接，但是这种方法还是有一个缺点。它不支持Java8的日期类型，例如<code>LocalDate</code>和<code>LocalDateTime</code>，它只能用来格式化<code>Date</code>或<code>Calendar</code>类型的字段。</p><h2 id="4-自定义Jackson的ObjectMapper"><a href="#4-自定义Jackson的ObjectMapper" class="headerlink" title="4.自定义Jackson的ObjectMapper"></a>4.自定义Jackson的ObjectMapper</h2><p>因此，如果我们想使用Java 8日期类型，并设置默认的日期格式，那么我们需要研究创建<code>Jackson2ObjectMapperBuilderCustomizer</code>：</p><pre><code class="java">@Configuration@ConditionalOnClass(ObjectMapper.class)@AutoConfigureBefore(JacksonAutoConfiguration.class)public class JacksonConfig {        private static final String NORM_DATE_PATTERN = &quot;yyyy-MM-dd&quot;;        private static final String NORM_TIME_PATTERN = &quot;HH:mm:ss&quot;;        private static final String NORM_DATETIME_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;        @Bean        public Jackson2ObjectMapperBuilderCustomizer customizer() {                return builder -&gt; {                        builder.simpleDateFormat(NORM_DATETIME_FORMAT);                        //属性值为null的不参与序列化            builder.serializationInclusion(JsonInclude.Include.NON_NULL);             builder.serializers(new LocalTimeSerializer(DateTimeFormatter.ofPattern(NORM_TIME_PATTERN)));             builder.serializers(new LocalDateSerializer(DateTimeFormatter.ofPattern(NORM_DATE_PATTERN)));             builder.serializers(new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(NORM_DATETIME_FORMAT)));                };        }}</code></pre><p>上面的示例显示了如何在我们的应用程序中配置默认格式。我们必须定义一个bean并覆盖它的customize方法来设置所需的格式，重要的是它可以同时支持Java8和旧式日期类型。</p><h2 id="5-其他注意事项"><a href="#5-其他注意事项" class="headerlink" title="5.其他注意事项"></a>5.其他注意事项</h2><h3 id="5-1-无法找到com-fasterxml-jackson-datatype-jsr310-ser-LocalDateSerializer"><a href="#5-1-无法找到com-fasterxml-jackson-datatype-jsr310-ser-LocalDateSerializer" class="headerlink" title="5.1 无法找到com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer"></a>5.1 无法找到<code>com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer</code></h3><p>需要我们在<strong>Pom</strong>添加额外的依赖</p><pre><code>&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
